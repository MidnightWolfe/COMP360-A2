extends Path3D
#This will require a matrix script to work, current one is from the lab /class and will need adjusted
#This will be changed with the addition of a space-filling curve

#Currently does not display in the landscape, still working on that part. Only displays as a 2D image in the corner

##Generating points for the spline curve, may need to add more, or remove some
##Might need to scale all of these to be in the 100 by 100 range
##Need to get these points to connect at the end, as currently it is just a curved line
var points = [
	Vector2(10.0, 50.0),
	Vector2(50.0, 70.0),
	Vector2(30.0, 10.0),
	Vector2(75.0, 65.0),
	Vector2(90.0, 100.0),
	Vector2(100.0, 95.0),
	Vector2(20.0,20.0),
	Vector2(15.0, 40.0),
	Vector2(10.0, 50.0)
]

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	catmull_rom()
	pass # Replace with function body.

##This will need to be recursive
func spline(res, s, p): #p is for the altered points, res is the resolution, s is the scale
	var pts = []
	for k in range(res+1):
		var t = float(k) / res
		var PolyT = Matrix.new(1, 4)
		PolyT.set_data( #Polynominal for the value t
			[ [ 1, t, t*t, t*t*t ] ]
		)
		var CharMtx = Matrix.new(4, 4)
		CharMtx.set_data(#The matrix information for cardinal splines
			[
				[0, 1, 0, 0],
				[-s, 0, s, 0],
				[2*s, s-3, 3-2*s, -s],
				[-s, 2-s, s-2, s]
			]
		)
		var PtMtx = Matrix.new(4, 1)
		PtMtx.set_data(p)
		var R = PolyT.multiply(CharMtx).multiply(PtMtx)
		pts.append(R.get_value(0, 0))
	return pts
	
	
	
##Math to recursively make the spline (will be changed with space-filling curve)
##Currently based on our lab / lecture code, but will change it as needed
func catmull_rom():
	var s = 0.5 #Scale of the matrix, 0.5 makes this a catmull-rom, which is based on cardinal splines
	var res = 40
	var width = 200 #width of the 2D image
	var height = 200 #Height of the 2D Image
	var image = Image.create(width, height, false, Image.FORMAT_RGBA8)
	image.fill(Color.BLACK)
	#Might need to change this to match the cardinal spline information from the slides
	for k in range(points.size()-3):
		var pts: Array;
		pts = spline(
			res, s,
			[
				[points[k]],
				[points[k+1]],
				[points[k+2]],
				[points[k+3]]
			]
		)
		
		#This loop shows the cardinal / catmull-rom spline
		for i in range(pts.size()-1):
			bresenham_line(image, Color.WHITE, pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y )
			
	#This loop shows the original "jagged" points spline
	#for i in range(points.size()-1):
	#	bresenham_line(image, Color.YELLOW, points[i].x, points[i].y, points[i+1].x, points[i+1].y )
	
	var texture = ImageTexture.create_from_image(image)
	var sprite = Sprite2D.new()
	sprite.texture_filter = CanvasItem.TEXTURE_FILTER_NEAREST
	sprite.texture = texture
	sprite.position = Vector2(width/2.0 + 20, height/2.0 + 20)
	add_child(sprite)
	pass


	
##To draw the circle / path of the spline in the landscape, may need this for the space-filling curve
func draw_circle():
	pass


#May need to adjust this function as needed, from our slides
# bresenham_line Generated by Gemini
# 2024 Jul 13
func bresenham_line(image, c, fx0, fy0, fx1, fy1):
	var x0 = floor(fx0)
	var x1 = floor(fx1)
	var y0 = floor(fy0)
	var y1 = floor(fy1)
	var dx = abs(x1 - x0)
	var dy = -abs(y1 - y0)
	var sx = 1 if x0 < x1 else -1
	var sy = 1 if y0 < y1 else -1
	var err = dx + dy
	
	while true:
		image.set_pixel(floor(x0), floor(y0), c) # edited
		if x0 == x1 and y0 == y1:
			break

		var e2 = 2 * err
		if e2 >= dy:
			err += dy
			x0 += sx
		if e2 <= dx:
			err += dx
			y0 += sy
